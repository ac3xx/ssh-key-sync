package command

import (
	"bytes"
	"io"
	"io/ioutil"
	"os"
	"strings"
	"time"

	"github.com/shoenig/ssh-key-sync/internal/ssh"
)

func generateFileContent(keys []ssh.Key, now time.Time) string {
	var buf bytes.Buffer

	formattedTime := now.Format(time.RFC1123)
	buf.WriteString("# Autogenerated by ssh-key-sync on " + formattedTime + "\n\n")

	for _, key := range keys {
		if key.Managed {
			buf.WriteString("# managed by ssh-key-sync\n")
		}
		buf.WriteString(key.Value)
		if key.User != "" && key.Host != "" {
			buf.WriteString(" ")
			buf.WriteString(key.User)
			buf.WriteString("@")
			buf.WriteString(key.Host)
		}
		buf.WriteString("\n\n")
	}

	return buf.String()
}

// safely write to a tmp file and then do an atomic rename
func (e *execer) writeToFile(file, user, content string) error {
	f, err := ioutil.TempFile("", "ssh-key-sync-")
	if err != nil {
		return err
	}

	reader := strings.NewReader(content)

	if _, err := io.Copy(f, reader); err != nil {
		return err
	}

	// flush the tmpfile complettely to disk
	if err := f.Sync(); err != nil {
		return err
	}

	// close the tmpfile
	if err := f.Close(); err != nil {
		return err
	}

	// chown the file to user
	if err := e.touch(f.Name(), user); err != nil {
		return err
	}

	// atmoically rename the file
	return os.Rename(f.Name(), file)
}
